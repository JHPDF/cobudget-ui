Decimal = require('big.js')
Moment = require('moment')
_ = require('lodash')

sum = require('utils/sum')

### @ngInject ###
module.exports = (AuthService, BaseModel, BaseCollection, AllocationModel, BucketModel, FixedCostModel) ->
  BaseModel.extend
    
    type: "Round"

    props:
      groupId: "number"
      name: "string"
      startsAt: "moment"
      endsAt: "moment"

    children:
      allocations: BaseCollection.extend
        model: AllocationModel
      buckets: BaseCollection.extend
        model: BucketModel
      fixedCosts: BaseCollection.extend
        model: FixedCostModel

    derived:
      status:
        deps: ['startsAt, endsAt']
        fn: ->
          now = Moment()
          if (@startsAt.isAfter(now))
            changeLabel = "starts"
            changeTime = @startsAt.from(now)
            return {
              name: "pending"
              class: "info"
              label: changeLabel + " " + changeTime
              changeLabel: changeLabel
              changeTime: changeTime
            }
          else if (@startsAt.isBefore(now) and @endsAt.isAfter(now))
            return {
              name: "open"
              class: "success"
              label: "open now, ends " + @endsAt.from(now)
              changeLabel: "time left"
              changeTime: @endsAt.from(now, true)
            }
          else
            changeLabel = "ended"
            changeTime = @endsAt.from(now)
            return {
              name: "closed"
              class: "warning"
              label: changeLabel + " " + changeTime
              changeLabel: changeLabel
              changeTime: changeTime
            }

      myContributions:
        deps: ['buckets.myContribution']
        fn: ->
          @buckets.map (bucket) ->
            bucket.myContribution

      myAllocationIndex:
        deps: ['allocations.userId']
        fn: ->
          @allocations.findIndex (allocation) ->
            allocation.userId == AuthService.getCurrentUser().id

      myAllocation:
        deps: ['myAllocationIndex', 'allocations']
        fn: ->
          index = @myAllocationIndex
          if index != -1
            @allocations.at(index)
          else
            new AllocationModel({
              userId: AuthService.getCurrentUser().id
              roundId: @id
              amountCents: 0
            })

      groupAllocations:
        deps: ['allocations.user.id']
        fn: ->
          @allocations.filter (allocation) ->
            allocation.user.id != AuthService.getCurrentUser().id

      allocationsTotal:
        deps: ['allocations.amount']
        fn: ->
          sum(@allocations.pluck "amount")

      myContributionsTotal:
        deps: ['myContributions.amount']
        fn: ->
          sum(_.pluck @myContributions, "amount")

      myAllocationLeft:
        deps: ['myAllocation.amount', 'myContributionsTotal']
        fn: ->
          @myAllocation.amount.minus(@myContributionsTotal)

      totalAllocated:
        deps: ['buckets.contributionTotal']
        fn: ->
          sum(@buckets.pluck "contributionTotal")

      totalAllocable:
        deps: ['allocations.amount']
        fn: ->
          sum(@allocations.pluck "amount")

      balanceStatus:
        deps: ['myAllocationLeft']
        fn: ->
          if (@myAllocationLeft.gt(0))
            null
          else if (@myAllocationLeft.eq(0))
            'complete'
          else
            'warning'

      fixedCostTotal:
        deps: ['fixedCosts.amount']
        fn: ->
          sum(@fixedCosts.pluck "amount")

    serialize: ->
      serialized = BaseModel.prototype.serialize.call(@)
      serialized.startsAt = serialized.startsAt.toISOString()
      serialized.endsAt = serialized.endsAt.toISOString()
      serialized

    getAllocationsByUser: ->
      # index allocations by user id
      allocationsByUserId = {}
      @allocations.forEach (allocation) ->
        allocationsByUserId[allocation.userId] = allocation
      allocationsByUserId

    getContributors: (memberships) ->
      contributors = {}

      allocationsByUserId = @getAllocationsByUser()

      # for each member
      _.each memberships, (membership) ->
        contributor = {
          user: membership.user
        }

        allocation = allocationsByUserId[contributor.user.id]

        if (allocation)
          contributor.allocation = allocation.amount

        contributors[contributor.user.id] = contributor

      # for each bucket
      @buckets.forEach (bucket) ->
        contributions = bucket.getContributionsByUser()

        # add contributions to contributors
        _.each contributions, (contribution, userId) ->

          contributor = contributors[userId]

          if not contributors or not contributor
            return

          if not contributor.contribution
            contributor.contribution = contribution.amount
          else
            contribution.contribution = contributor.contribution.plus(contribution.amount)

      contributors

