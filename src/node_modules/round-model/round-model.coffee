Decimal = require('big.js')
Moment = require('moment')
sum = require('compute-sum')
_ = require('lodash')

### @ngInject ###
module.exports = (AuthService, AllocationModel, BucketModel, FixedCostModel) ->
  class RoundModel
    constructor: (data = {}) ->
      @id = data.id
      @name = data.name
      @groupId = data.groupId

      @startsAt = Moment(data.startsAt)
      @endsAt = Moment(data.endsAt)

      @allocations = _.map data.allocations, (allocation) ->
        new AllocationModel(allocation)
      @buckets = _.map data.buckets, (bucket) ->
        new BucketModel(bucket)
      @fixedCosts = _.map data.fixedCosts, (fixedCost) ->
        new FixedCostModel(fixedCost)

      Object.defineProperties @,
        status:
          get: ->
            now = Moment()
            if (@startsAt.isAfter(now))
              changeLabel = "starts"
              changeTime = @startsAt.from(now)
              return {
                name: "pending"
                class: "info"
                label: changeLabel + " " + changeTime
                changeLabel: changeLabel
                changeTime: changeTime
              }
            else if (@startsAt.isBefore(now) and @endsAt.isAfter(now))
              return {
                name: "open"
                class: "success"
                label: "open now, ends " + @endsAt.from(now)
                changeLabel: "time left"
                changeTime: @endsAt.from(now, true)
              }
            else
              changeLabel = "ended"
              changeTime = @endsAt.from(now)
              return {
                name: "closed"
                class: "warning"
                label: changeLabel + " " + changeTime
                changeLabel: changeLabel
                changeTime: changeTime
              }


        myContributions:
          get: ->
            _.map @buckets, (bucket) ->
              bucket.myContribution

        myAllocation:
          get: ->
            currentUserId = AuthService.getCurrentUser().id
            (_.find @allocations, (allocation) ->
              allocation.userId == currentUserId
            ) or new AllocationModel({
              userId: currentUserId
              roundId: @id
              amountCents: 0
            })

        groupAllocations:
          get: ->
            _.filter @allocations, (allocation) ->
              allocation.user.id != AuthService.getCurrentUser().id

        allocationsTotalCents:
          get: ->
            sum(_.pluck @allocations, "amountCents")

        allocationsTotal:
          get: ->
            @allocationsTotalCents / 100

        myContributionsCents:
          get: ->
            sum(_.pluck @myContributions, "amountCents")

        myAllocationAmountCents:
          get: ->
            @myAllocation.amountCents

        myAllocationAmount:
          get: ->
            @myAllocationAmountCents / 100

        myAllocationLeftCents:
          get: ->
            @myAllocationAmountCents - @myContributionsCents

        myAllocationLeft:
          get: ->
            @myAllocationLeftCents / 100

        totalAllocatedCents:
          get: ->
            sum(_.pluck @allocations, "amountCents")

        totalAllocated:
          get: ->
            @totalAllocatedCents / 100

        totalAllocableCents:
          get: ->
            sum(_.pluck @buckets, "contributionTotalCents")

        totalAllocable:
          get: ->
            @totalAllocableCents / 100

        balanceStatus:
          get: ->
            if (@myAllocationLeftCents > 0)
              null
            else if (@myAllocationLeftCents == 0)
              'complete'
            else
              'warning'

    serialize: ->
      {
        id: @id
        name: @name
        groupId: @groupId
        startsAt: @startsAt.toISOString()
        endsAt: @endsAt.toISOString()
      }

    getAllocationsByUser: ->
      # index allocations by user id
      allocationsByUserId = {}
      _.each @allocations, (allocation) ->
        allocationsByUserId[allocation.userId] = allocation
      allocationsByUserId

    getTotalAllocationsDollars: ->
      # index allocations by user id
      total = 0
      _.each @allocations, (allocation) ->
        total += allocation.amountCents

      total = total / 100

    getContributors: (memberships) ->
      contributors = {}

      allocationsByUserId = @getAllocationsByUser()

      # for each member
      _.each memberships, (membership) ->
        contributor = {
          user: membership.user
        }

        allocation = allocationsByUserId[contributor.user.id]

        if (allocation)
          contributor.allocationCents = allocation.amountCents

        contributor.allocation = contributor.allocationCents / 100

        contributors[contributor.user.id] = contributor

      # for each bucket
      _.each @buckets, (bucket) ->
        contributions = bucket.getContributionsByUser()

        # add contributions to contributors
        _.each contributions, (contribution, userId) ->

          contributor = contributors[userId]

          if not contributors or not contributor
            return

          if not contributor.contributionCents
            contributor.contributionCents = contribution.amountCents
          else
            contributor.contributionCents += contribution.amountCents

          contributor.contribution = contributor.contributionCents / 100

      contributors

    getFixedCostCents: ->
      @fixedCostCents =
        _.reduce(_.pluck(@fixedCosts, "amount"), (sum, num) ->
          sum.plus(num or new Decimal(0))
        , new Decimal(0))
        .times(100).toFixed(0)

